import logging
import pandas as pd

from apps.backtesting.legacy_postgres import NoPriceDataException
from collections import OrderedDict

from apps.backtesting.rebalancing.rebalancing_actors import Allocation, PortfolioSnapshot, PRICE_PROVIDER
from apps.backtesting.tick_provider_df import TickProviderDataframe
from apps.backtesting.utils import datetime_to_timestamp
from apps.backtesting.legacy_postgres import POSTGRES
from abc import ABC, abstractmethod


class PortfolioBacktester(ABC):
    '''
    General-purpose portfolio backtester. Runs through time, computes the value of a portfolio and various statistics at
    each time point. To supply portfolio snapshots generated by specific portfolio management strategies, override the
    method _build_portfolio_snapshots in derived classes.
    '''

    def __init__(self, start_time, end_time, step_seconds, counter_currency, verbose=False, trading_cost_percent=0, baseline_portions=None,
                 db_interface=POSTGRES):
        '''
        Constructs the portfolio backtester.
        :param start_time: starting time of the simulation
        :param end_time: end time of the simulation
        :param step_seconds: simulation step (portfolio value is gauged every step_seconds)
        :param counter_currency: counter currency used in the portfolio
        :param verbose: verbose output flag
        :param trading_cost_percent: assumed trading costs per transaction
        '''
        if isinstance(start_time, str):
            start_time = int(datetime_to_timestamp(start_time))
        if isinstance(end_time, str):
            end_time = int(datetime_to_timestamp(end_time))

        self._start_time = start_time
        self._end_time = end_time
        self._step_seconds = step_seconds
        self._counter_currency = counter_currency
        self._verbose = verbose
        self._trading_cost_percent = trading_cost_percent
        self._db_interface = db_interface
        self._build_portfolio_snapshots()
        self._start_value_of_portfolio = list(self._portfolio_snapshots.items())[0][1].total_value(counter_currency)
        self._start_value_of_portfolio_usdt = list(self._portfolio_snapshots.items())[0][1].total_value('USDT')
        self._baseline_portions = baseline_portions

        self._simulate()
        self._build_benchmark_baselines()
        self._fill_benchmark_dataframe()


    @abstractmethod
    def _build_portfolio_snapshots(self):
        pass

    def _build_benchmark_baselines(self):

        if self._baseline_portions == None:   # divide everything equally among held assets:
            baseline_portions = {coin: 1.0/len(self.held_assets) for coin in self.held_assets}
        else:
            baseline_portions = self._baseline_portions
        self._benchmarks = {}
        self._usdt_benchmarks = {}
        from apps.backtesting.backtester_ticks import TickDrivenBacktester
        for asset in self.held_assets:
            asset_df = self.get_dataframe_for_asset(asset)
            tick_provider = TickProviderDataframe(transaction_currency=asset,
                                                  counter_currency='BTC',
                                                  source='binance',
                                                  dataframe=asset_df,
                                                  close_price_column_name='unit_price')

            from apps.backtesting.data_sources import RedisDB
            if isinstance(self._db_interface, RedisDB):
                source = 'binance'
            else:
                source = 2   # dirty hack, TODO fix
            self._benchmarks[asset] = TickDrivenBacktester.build_benchmark(asset, 'BTC',
                                                                          self._start_value_of_portfolio*baseline_portions[asset],
                                                                          0, self._start_time, self._end_time,
                                                                          source=source, tick_provider=tick_provider,
                                                                          database=self._db_interface)
            tick_provider_usdt = TickProviderDataframe(transaction_currency=asset,
                                                       counter_currency='USDT',
                                                       source='binance',
                                                       dataframe=asset_df,
                                                       close_price_column_name='unit_price_usdt')
            self._usdt_benchmarks[asset] = TickDrivenBacktester.build_benchmark(asset, 'USDT',
                                                                          self._start_value_of_portfolio_usdt*baseline_portions[asset],
                                                                          0, self._start_time, self._end_time,
                                                                          source=source, tick_provider=tick_provider_usdt,
                                                                          database=self._db_interface)

    def _simulate(self):
        self._dataframes = {}
        value_df_dicts = []
        current_snapshot = None
        previous_snapshot = None
        start_time = max(self._start_time,
                         min(list(self._portfolio_snapshots.keys())) if len(self._portfolio_snapshots) > 0 else 0)
        for timestamp in range(start_time, self._end_time+1, self._step_seconds):
            try:
                current_snapshot = self._get_next_snapshot(current_snapshot, timestamp, previous_snapshot)
                if current_snapshot is None:   # ran out of data
                    break
                if self._verbose:
                    current_snapshot.report()
                logging.info(current_snapshot.to_dict())
                current_value_of_portfolio = current_snapshot.total_value(self._counter_currency)
                asset_values_dict = {}
                for asset in current_snapshot.to_dict().keys():
                    self._dataframes.setdefault(asset, []).append(current_snapshot.to_dict()[asset])
                    allocation_dict = current_snapshot.get_allocation(asset).to_dict(prefix=f'{asset}_')
                    for key in allocation_dict:
                        asset_values_dict[key] = allocation_dict[key]
                    # asset_values_dict[asset] = current_snapshot.get_allocation(asset).value
                asset_values_dict['timestamp'] = timestamp
                asset_values_dict['total_value'] = current_value_of_portfolio
                asset_values_dict['total_value_usdt'] = current_snapshot.total_value('USDT')
                value_df_dicts.append(asset_values_dict)
                previous_snapshot = current_snapshot
            except NoPriceDataException as e:
                logging.error(e)
                continue
        self._dataframes = {asset: pd.DataFrame(self._dataframes[asset]).set_index(['timestamp']) for asset in self._dataframes.keys()}
        self._value_dataframe = pd.DataFrame(value_df_dicts).set_index(['timestamp'])
        self._value_dataframe = self._fill_relative_returns(self._value_dataframe,
                                                            total_value_column_name='total_value',
                                                            relative_returns_column_name='return_relative_to_past_tick')
        self._value_dataframe = self._fill_relative_returns(self._value_dataframe,
                                                            total_value_column_name='total_value_usdt',
                                                            relative_returns_column_name='return_relative_to_past_tick_usdt')

        # self._value_dataframe.index = pd.to_datetime(self._value_dataframe.index, unit='s')

    def _get_next_snapshot(self, current_snapshot, timestamp, previous_snapshot):
        if timestamp in self._portfolio_snapshots:
            return self._portfolio_snapshots[timestamp]    # we have a rebalancing checkpoint here
        else:
            return current_snapshot.update_to_timestamp(timestamp)   # just recalculate value and return


    def _fill_relative_returns(self, df, total_value_column_name='total_value', relative_returns_column_name='return_relative_to_past_tick'):
        df['return_relative_to_past_tick'] = df[total_value_column_name].diff() / df[total_value_column_name].shift(1)
        return df

    def process_allocations(self, timestamp, allocations_data):
        self._portfolio_snapshots[timestamp] = PortfolioSnapshot(timestamp, allocations_data,
                                                                 counter_currency=self._counter_currency,
                                                                 db_interface=self._db_interface)

    def value_report(self):
        for timestamp, snapshot in self._portfolio_snapshots.items():
            snapshot.report()

    def get_dataframe_for_asset(self, asset):
        return self._dataframes.get(asset, None)

    def get_rebalancing_vs_benchmark_dataframe(self):
        value_df = self.value_dataframe
        benchmark_value_df = self.get_benchmark_trading_df_for_all_assets()

        df = value_df.join(benchmark_value_df, lsuffix='_rebalancing', rsuffix='_benchmark')
        columns_list = [f'total_value_{asset}' for asset in self.held_assets]
        columns_list.append('total_value_rebalancing')
        columns_list.append('total_value_benchmark')
        df.index = pd.to_datetime(df.index, unit='s')
        return df

    @property
    def value_dataframe(self):
        return self._value_dataframe

    @property
    def held_assets(self):
        return self._portions_dict.keys()

    @property
    def start_time(self):
        return self._start_time

    @property
    def end_time(self):
        return self._end_time

    def get_benchmark_for_asset(self, asset):
        return self._benchmarks.get(asset, None)

    def get_benchmark_trading_dataframe_for_asset(self, asset):
        if asset not in self._benchmarks:
            return None
        return self._benchmarks[asset].trading_df

    def _fill_benchmark_dataframe(self):
        df = None
        for asset in self.held_assets:
            if df is None:
                df = self._benchmarks[asset].trading_df.copy()
                df = df.add_suffix(f'_{asset}')
                right_usdt = self._usdt_benchmarks[asset].trading_df.copy().add_suffix(f'_usdt_{asset}')
                df = df.join(right_usdt)
            else:
                right = self._benchmarks.get(asset, None).trading_df.add_suffix(f'_{asset}')
                df = df.join(right)
                right_usdt = self._usdt_benchmarks[asset].trading_df.copy().add_suffix(f'_usdt_{asset}')
                df = df.join(right_usdt)
        sum_columns = [f'total_value_{asset}' for asset in self.held_assets]
        df['total_value'] = df[sum_columns].sum(axis=1)
        df = self._fill_relative_returns(df, total_value_column_name='total_value', 
                                         relative_returns_column_name='return_relative_to_past_tick')

        sum_columns_usdt = [f'total_value_usdt_{asset}' for asset in self.held_assets]
        df['total_value_usdt'] = df[sum_columns_usdt].sum(axis=1)
        df = self._fill_relative_returns(df, total_value_column_name='total_value_usdt', 
                                         relative_returns_column_name='return_relative_to_past_tick_usdt')

        self._benchmark_dataframe = df

    def _build_portfolio(self, timestamp, total_value, target_portions):
        allocations = []
        # calculate the held amount for each asset
        for asset in target_portions:
            portion = target_portions[asset]
            unit_price = PRICE_PROVIDER.get_price(asset, timestamp,
                                                  db_interface=self._db_interface, counter_currency=self._counter_currency)
            value = (portion * total_value) * (1 - self._trading_cost_percent / 100)
            amount = value / unit_price
            allocation = Allocation(amount=amount, asset=asset, portion=portion, timestamp=timestamp,
                                    counter_currency=self._counter_currency, unit_price=unit_price, value=value,
                                    db_interface=self._db_interface)
            allocations.append(allocation)
        return PortfolioSnapshot(timestamp=timestamp, allocations_data=allocations,
                                 load_from_json=False, counter_currency=self._counter_currency, db_interface=self._db_interface)

    def _build_portfolio_with_trading_fee(self, timestamp, total_value, previous_portfolio, target_portions):
        if previous_portfolio is None:
            return self._build_portfolio(timestamp, total_value, target_portions=target_portions)
        allocations = []
        trading_fee = self._trading_cost_percent / 100
        # calculate the held amount for each asset
        for asset in target_portions:
            previous = previous_portfolio.get_allocation(asset)
            new_unit_price = PRICE_PROVIDER.get_price(asset, timestamp,  db_interface=self._db_interface,
                                                      counter_currency=self._counter_currency)
            portion = target_portions[asset]
            delta_value = abs(total_value * portion - previous.amount * new_unit_price)
            fee = delta_value * trading_fee
            obtained_amount = (delta_value - fee) / new_unit_price
            new_amount = previous.amount + (
                obtained_amount if total_value * portion > previous.amount * new_unit_price else -obtained_amount)
            new_value = new_amount * new_unit_price
            portion = new_value / total_value
            # amount = value / unit_price
            allocation = Allocation(amount=new_amount, asset=asset, portion=portion, timestamp=timestamp,
                                    counter_currency=self._counter_currency, unit_price=new_unit_price, value=new_value,
                                    db_interface=self._db_interface)
            allocations.append(allocation)
        total_value = sum([allocation.value for allocation in allocations])
        for allocation in allocations:
            allocation.portion = allocation.value / total_value

        p = PortfolioSnapshot(timestamp=timestamp, allocations_data=allocations, load_from_json=False,
                              counter_currency=self._counter_currency, db_interface=self._db_interface)
        return p

    def get_benchmark_trading_df_for_all_assets(self):
        return self._benchmark_dataframe

    @property
    def profit(self):
        end_value = self.value_dataframe.iloc[-1].total_value
        return end_value - self._start_value_of_portfolio

    @property
    def profit_usdt(self):
        end_value = self.value_dataframe.iloc[-1].total_value_usdt
        return end_value - self._start_value_of_portfolio_usdt

    @property
    def profit_percent(self):
        return self.profit / float(self._start_value_of_portfolio)

    @property
    def profit_percent_usdt(self):
        return self.profit_usdt / float(self._start_value_of_portfolio_usdt)

    @property
    def benchmark_profit(self):
        end_value = self._benchmark_dataframe.iloc[-1].total_value
        return end_value - self._start_value_of_portfolio

    @property
    def benchmark_profit_usdt(self):
        end_value = self._benchmark_dataframe.iloc[-1].total_value_usdt
        return end_value - self._start_value_of_portfolio_usdt

    @property
    def benchmark_profit_percent(self):
        return self.benchmark_profit / float(self._start_value_of_portfolio)

    @property
    def benchmark_profit_percent_usdt(self):
        return self.benchmark_profit_usdt / float(self._start_value_of_portfolio_usdt)

    @property
    def gain_over_benchmark(self):
        return self.profit - self.benchmark_profit

    @property
    def gain_over_benchmark_usdt(self):
        return self.profit_usdt - self.benchmark_profit_usdt

    @property
    def percent_gain_over_benchmark(self):
        return self.gain_over_benchmark / self._start_value_of_portfolio

    @property
    def percent_gain_over_benchmark_usdt(self):
        return self.gain_over_benchmark_usdt / self._start_value_of_portfolio_usdt

    @property
    def summary_dict(self):
        return {
            'allocations': ', '.join([f'{asset} ({self.get_portion(asset)*100:.0f}%)' for asset in self.held_assets]),
            'profit_percent': self.profit_percent,
            'profit_percent_usdt': self.profit_percent_usdt,
            'benchmark_profit_percent': self.benchmark_profit_percent,
            'benchmark_profit_percent_usdt': self.benchmark_profit_percent_usdt,
            'percent_gain_over_benchmark': self.percent_gain_over_benchmark,
            'percent_gain_over_benchmark_usdt': self.percent_gain_over_benchmark_usdt,
            'gain_over_benchmark': self.gain_over_benchmark,
            'gain_over_benchmark_usdt': self.gain_over_benchmark_usdt
        }

    def get_portion(self, asset):
        return self._portions_dict.get(asset, None)

    def draw_returns_tear_sheet(self, save_file=True, out_filename='pyfolio_returns_tear_sheet.png'):
        import pyfolio as pf
        import matplotlib
        if save_file:
           matplotlib.use('Agg')

        df = self.get_rebalancing_vs_benchmark_dataframe()
        df = df.rename(columns={"return_relative_to_past_tick_benchmark": "Buy & hold"})
        f = pf.create_returns_tear_sheet(returns=df['return_relative_to_past_tick_rebalancing'],
                                         return_fig=True,
                                         bootstrap=None,
                                         benchmark_rets=df['Buy & hold'])

        if save_file:
            f.savefig(out_filename)
        return f

    def plot_returns(self, title=None):
        if title is None:
            title = self.summary_dict['allocations']
        self.get_rebalancing_vs_benchmark_dataframe()[
            ['total_value_usdt_rebalancing', 'total_value_usdt_benchmark']].plot(title=title)

    def save_returns_plot(self, out_file_path, title=None):
        if title is None:
            title = self.summary_dict['allocations']
        chart = self.get_rebalancing_vs_benchmark_dataframe()[
            ['total_value_usdt_rebalancing', 'total_value_usdt_benchmark']].plot(title=title)
        chart.set_xlabel('')
        chart.set_ylabel('')
        chart.legend(['total value usdt rebalancing', 'buy & hold'])
        fig = chart.get_figure()
        fig.savefig(out_file_path)
        return fig



class RebalancingStrategyBacktester(PortfolioBacktester):
    '''
    Enables backtesting an arbitrary rebalancing strategy.
    '''

    def __init__(self, portfolio_snapshots, *args, **kwargs):
        '''
        Constructs the rebalancing strategy backtester.
        :param portfolio_snapshots: a dictionary of pairs <timestamp>-<PortfolioSnapshot> generated by the strategy
        :param args: arguments for the super constructor (see PortfolioBacktester)
        :param kwargs: arguments for the super constructor (see PortfolioBacktester)
        '''
        self._cached_portfolio_snapshots = portfolio_snapshots
        super().__init__(*args, **kwargs)

    def _build_portfolio_snapshots(self):
        self._portfolio_snapshots = self._cached_portfolio_snapshots



class FixedRatiosPortfolioBacktester(PortfolioBacktester):
    '''
    A backtester that assumes fixed preset asset ratios (e.g. 50% BTC, 50% ETH) and simulates the performance
    of the portfolio assuming these ratios are kept.
    '''

    def __init__(self, rebalancing_period_seconds, portions_dict,
                 start_value_of_portfolio, *args, **kwargs):
        '''
        Builds and runs the fixed ratios backtester.
        :param rebalancing_period_seconds: how often to rebalance the portfolio
        :param portions_dict: a dictionary of key-value pairs where key is
                              the name of the asset and value is the portion (on a scale 0-1)
        :param start_value_of_portfolio: start value of the p
        :param args: arguments for the super constructor (see PortfolioBacktester)
        :param kwargs: arguments for the super constructor (see PortfolioBacktester)
        '''
        self._rebalancing_period_seconds = rebalancing_period_seconds
        self._portions_dict = portions_dict
        self._start_value_of_portfolio = start_value_of_portfolio
        super().__init__(baseline_portions=portions_dict, *args, **kwargs)




    def _build_portfolio_snapshots(self):
        self._portfolio_snapshots = OrderedDict()
        current_snapshot = None
        for timestamp in range(self._start_time, self._end_time + 1, self._rebalancing_period_seconds):
            try:
                previous_snapshot = current_snapshot
                current_snapshot = self._get_next_snapshot(current_snapshot, timestamp, previous_snapshot)
                self._portfolio_snapshots[timestamp] = current_snapshot
            except NoPriceDataException as e:
                logging.error(f'Unable to load price data at {timestamp}, skipping snapshot: {str(e)}...')


    def _get_next_snapshot(self, current_snapshot, timestamp, previous_snapshot):
        if current_snapshot is None:
            current_snapshot = self._build_portfolio_with_trading_fee(self._start_time, self._start_value_of_portfolio,
                                                                      previous_portfolio=None, target_portions=self._portions_dict)
        else:
            current_snapshot = self._build_portfolio_with_trading_fee(
                timestamp, current_snapshot.update_to_timestamp(timestamp).total_value(self._counter_currency),
                previous_portfolio=previous_snapshot, target_portions=self._portions_dict)
        return current_snapshot


class RealDogeTradingBacktester(PortfolioBacktester):
    """
    Enables building a backtester from real trading data stored in Postgres DB.
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


    def _build_portfolio_snapshots(self):
        from apps.portfolio.models.allocation import Allocation as DatabaseAllocationRecord
        import datetime

        self._portfolio_snapshots = OrderedDict()
        allocations = DatabaseAllocationRecord.objects.filter(
            _timestamp__gte=datetime.datetime.utcfromtimestamp(self.start_time),
            _timestamp__lte=datetime.datetime.utcfromtimestamp(self.end_time))

        for allocation in allocations:
            realized_allocation = allocation.realized_allocation
            timestamp = allocation._timestamp

            try:
                portfolio_allocations = []
                for item in realized_allocation:
                    portfolio_allocations.append(Allocation(amount=item['amount'], asset=item['coin'],
                                                            portion=item['portion'], timestamp=timestamp,
                                                            db_interface=self._db_interface,
                                                            counter_currency=self._counter_currency))

                portfolio_snapshot = PortfolioSnapshot(timestamp=timestamp, allocations_data=portfolio_allocations,
                                                       db_interface=self._db_interface,
                                                       counter_currency=self._counter_currency,
                                                       load_from_json=False)
                self._portfolio_snapshots[timestamp] = portfolio_snapshot

            except Exception as e:
                logging.error(f'{str(e)}, skipping snapshot at {allocation._timestamp}...')


from apps.portfolio.services.doge_votes import get_allocations_from_doge, NoCommitteeVotesFoundException

class DogeRebalancingBacktester(PortfolioBacktester):
    '''
    Enables backtesting committee-based rebalancing
    '''

    def __init__(self, rebalancing_period_seconds, start_value_of_portfolio, *args, **kwargs):
        self._rebalancing_period_seconds = rebalancing_period_seconds
        self._start_value_of_portfolio = start_value_of_portfolio
        self._init_held_assets()
        super().__init__(*args, **kwargs)

    def _build_portfolio_snapshots(self):
        from apps.backtesting.utils import datetime_from_timestamp
        import datetime

        self._portfolio_snapshots = OrderedDict()

        for timestamp in range(self._start_time, self._end_time + 1, self._rebalancing_period_seconds):
            try:
                doge_allocations, _ = get_allocations_from_doge(at_datetime=datetime.datetime.utcfromtimestamp(timestamp))
                target_portons = self._doge_allocations_to_portions(doge_allocations)
                if len(self._portfolio_snapshots) == 0:   # first portfolio
                    snapshot = self._build_portfolio_with_trading_fee(timestamp=timestamp,
                                                                      total_value=self._start_value_of_portfolio,
                                                                      previous_portfolio=None,
                                                                      target_portions=target_portons)
                else:    # we already have previous data
                    previous_portfolio = self._portfolio_snapshots[list(self._portfolio_snapshots.keys())[-1]]
                    snapshot = self._build_portfolio_with_trading_fee(timestamp=timestamp,
                                                                      total_value=previous_portfolio.update_to_timestamp(timestamp).total_value(self._counter_currency),
                                                                      previous_portfolio=previous_portfolio,
                                                                      target_portions=target_portons)
                self._portfolio_snapshots[timestamp] = snapshot

            except NoPriceDataException as e:
                logging.error(f'Unable to load price data at {timestamp}, skipping snapshot: {str(e)}...')
            except NoCommitteeVotesFoundException as e:
                logging.error(f'{str(e)}, skipping snapshot...')
            except Exception as e:
                logging.critical(e)

    def _doge_allocations_to_portions(self, doge_allocations, fix_sum=True):
        result = {doge_allocation['coin']: doge_allocation['portion'] for doge_allocation in doge_allocations}
        if sum(result.values()) < 1:
            result['BTC'] += 1 - sum(result.values())
        return result


    def _init_held_assets(self):
        from settings.doge import SUPPORTED_DOGE_TICKERS
        assets = set()
        for ticker in SUPPORTED_DOGE_TICKERS:
            ticker = ticker.split('_')
            for coin in ticker:
                assets.add(coin)
        self._held_assets = list(assets)

    @property
    def held_assets(self):
        return self._held_assets




class DummyDataProvider:
    sample_allocations = """
    [{
        "amount": 0.00695246,
        "asset": "BTC",
        "portion": 0.5
    },{
        "amount": 0.05294586,
        "asset": "ETH",
        "portion": 0.5
    }]

    """

    def run(self):
        from apps.backtesting.rebalancing.backtester_portfolio import DogeRebalancingBacktester
        from apps.backtesting.data_sources import DB_INTERFACE
        from apps.backtesting.utils import datetime_to_timestamp, datetime_from_timestamp

        start_time = datetime_to_timestamp('2019/03/26 01:35:00 UTC')    ### TODO!!! figure out time shifts
        end_time = datetime_to_timestamp('2019/04/06 23:35:00 UTC')

        start_time = datetime_to_timestamp('2019/07/01 10:35:00 UTC')  ### TODO!!! figure out time shifts
        end_time = datetime_to_timestamp('2019/07/14 13:35:00 UTC')

        from apps.backtesting.rebalancing.backtester_portfolio import RealDogeTradingBacktester
        from apps.backtesting.data_sources import DB_INTERFACE
        from apps.backtesting.utils import datetime_to_timestamp, datetime_from_timestamp

        # import os
        # os.environ.setdefault("DJANGO_SETTINGS_MODULE", "web.settings")

        start_time = datetime_to_timestamp('2019/01/01 10:35:00 UTC')  ### TODO!!! figure out time shifts
        end_time = datetime_to_timestamp('2019/07/14 13:35:00 UTC')

        print(start_time)
        print(end_time)

        backtester = RealDogeTradingBacktester(start_time=datetime_from_timestamp(start_time),
                                               end_time=datetime_from_timestamp(end_time),
                                               step_seconds=60 * 20,
                                               counter_currency='USDT',
                                               db_interface=DB_INTERFACE, trading_cost_percent=0.1)
        df = backtester.value_dataframe




        start_time = DB_INTERFACE.get_nearest_committee_vote_timestamp(start_time, 'BTC_USDT',
                                                                       timestamp_tolerance=60 * 90)
        end_time = DB_INTERFACE.get_nearest_committee_vote_timestamp(end_time, 'BTC_USDT', timestamp_tolerance=60 * 90)

        print(start_time)
        print(end_time)

        backtester = DogeRebalancingBacktester(start_time=datetime_from_timestamp(start_time),
                                               end_time=datetime_from_timestamp(end_time),
                                               step_seconds=60 * 20,
                                               rebalancing_period_seconds=60 * 20,
                                               counter_currency='USDT',
                                               start_value_of_portfolio=100000000,
                                               db_interface=DB_INTERFACE, trading_cost_percent=0.1)

        exit(0)
        from apps.backtesting.utils import datetime_to_timestamp, datetime_from_timestamp
        # backtester = PortfolioBacktester()
        timestamp = datetime_to_timestamp('2019/02/01 00:00:00 UTC')
        # for i in range(10):
        #     backtester.process_allocations(timestamp+i*60*60*24, self.sample_allocations)
        # backtester.value_report()

        end_time = 1548250130  # time.time()
        start_time = end_time - 60 * 60 * 24 * 7

        import time
        end_time = 1555311600
        start_time = end_time - 60 * 60 * 24*3

        from apps.backtesting.data_sources import DB_INTERFACE

        start_time = DB_INTERFACE.get_nearest_db_timestamp(start_time, 'BTC_USDT')
        end_time = DB_INTERFACE.get_nearest_db_timestamp(end_time, 'BTC_USDT')


        backtester = DogeRebalancingBacktester(start_time=datetime_from_timestamp(start_time),
                                               end_time=datetime_from_timestamp(end_time),
                                               step_seconds=60 * 60,
                                               rebalancing_period_seconds=60 * 60,
                                               counter_currency='USDT',
                                               start_value_of_portfolio=100000000,
                                               db_interface=DB_INTERFACE)
        df = backtester.value_dataframe

        exit(0)


        backtester = FixedRatiosPortfolioBacktester(start_time=int(datetime_to_timestamp('2018/10/01 00:00:00 UTC')),
                            end_time=int(datetime_to_timestamp('2018/10/30 00:00:00 UTC')),
                            step_seconds=60*60,
                            rebalancing_period_seconds=60*60,
                            portions_dict={
                                'BTC': 0.5,
                                'ETH': 0.5,
                            },
                            start_value_of_portfolio=1000,
                            counter_currency='USDT',
                            trading_cost_percent=0.1) #, portfolio_snapshots=portfolio_snapshots)
        backtester.draw_returns_tear_sheet()
        backtester.get_benchmark_trading_dataframe_for_asset('ETH')
        backtester.get_benchmark_trading_df_for_all_assets()
        backtester.get_rebalancing_vs_benchmark_dataframe()

if __name__ == '__main__':
    d = DummyDataProvider()
    d.run()

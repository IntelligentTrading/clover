import logging
import pandas as pd

from apps.backtesting.legacy_postgres import NoPriceDataException
from collections import OrderedDict

from apps.backtesting.rebalancing.rebalancing_actors import Allocation, PortfolioSnapshot, PRICE_PROVIDER
from apps.backtesting.tick_provider_df import TickProviderDataframe
from apps.backtesting.utils import datetime_to_timestamp
from apps.backtesting.legacy_postgres import POSTGRES
from abc import ABC, abstractmethod


class PortfolioBacktester(ABC):
    '''
    General-purpose portfolio backtester. Runs through time, computes the value of a portfolio and various statistics at
    each time point. To supply portfolio snapshots generated by specific portfolio management strategies, override the
    method _build_portfolio_snapshots in derived classes.
    '''

    def __init__(self, start_time, end_time, step_seconds, counter_currency, verbose=False, trading_cost_percent=0):
        '''
        Constructs the portfolio backtester.
        :param start_time: starting time of the simulation
        :param end_time: end time of the simulation
        :param step_seconds: simulation step (portfolio value is gauged every step_seconds)
        :param counter_currency: counter currency used in the portfolio
        :param verbose: verbose output flag
        :param trading_cost_percent: assumed trading costs per transaction
        '''
        if isinstance(start_time, str):
            start_time = int(datetime_to_timestamp(start_time))
        if isinstance(end_time, str):
            end_time = int(datetime_to_timestamp(end_time))

        self._start_time = start_time
        self._end_time = end_time
        self._step_seconds = step_seconds
        self._counter_currency = counter_currency
        self._verbose = verbose
        self._trading_cost_percent = trading_cost_percent
        self._build_portfolio_snapshots()
        self._start_value_of_portfolio = list(self._portfolio_snapshots.items())[0][1].total_value(counter_currency)
        self._start_value_of_portfolio_usdt = list(self._portfolio_snapshots.items())[0][1].total_value('USDT')

        self._simulate()
        self._build_benchmark_baselines()
        self._fill_benchmark_dataframe()


    @abstractmethod
    def _build_portfolio_snapshots(self):
        pass

    def _build_benchmark_baselines(self):
        self._benchmarks = {}
        self._usdt_benchmarks = {}
        from apps.backtesting.backtester_ticks import TickDrivenBacktester
        for asset in self.held_assets:
            asset_df = self.get_dataframe_for_asset(asset)
            tick_provider = TickProviderDataframe(transaction_currency=asset,
                                                  counter_currency='BTC',
                                                  source='binance',
                                                  dataframe=asset_df,
                                                  close_price_column_name='unit_price')
            self._benchmarks[asset] = TickDrivenBacktester.build_benchmark(asset, 'BTC',
                                                                          self._start_value_of_portfolio*self._portions_dict[asset],
                                                                          0, self._start_time, self._end_time,
                                                                          source=2, tick_provider=tick_provider,
                                                                          database=POSTGRES)
            tick_provider_usdt = TickProviderDataframe(transaction_currency=asset,
                                                       counter_currency='USDT',
                                                       source='binance',
                                                       dataframe=asset_df,
                                                       close_price_column_name='unit_price_usdt')
            self._usdt_benchmarks[asset] = TickDrivenBacktester.build_benchmark(asset, 'USDT',
                                                                          self._start_value_of_portfolio_usdt*self._portions_dict[asset],
                                                                          0, self._start_time, self._end_time,
                                                                          source=2, tick_provider=tick_provider_usdt,
                                                                          database=POSTGRES)

    def _simulate(self):
        self._dataframes = {}
        value_df_dicts = []
        current_snapshot = None
        previous_snapshot = None
        for timestamp in range(self._start_time, self._end_time+1, self._step_seconds):
            try:
                current_snapshot = self._get_next_snapshot(current_snapshot, timestamp, previous_snapshot)
                if current_snapshot is None:   # ran out of data
                    break
                if self._verbose:
                    current_snapshot.report()
                logging.info(current_snapshot.to_dict())
                current_value_of_portfolio = current_snapshot.total_value(self._counter_currency)
                asset_values_dict = {}
                for asset in current_snapshot.to_dict().keys():
                    self._dataframes.setdefault(asset, []).append(current_snapshot.to_dict()[asset])
                    allocation_dict = current_snapshot.get_allocation(asset).to_dict(prefix=f'{asset}_')
                    for key in allocation_dict:
                        asset_values_dict[key] = allocation_dict[key]
                    # asset_values_dict[asset] = current_snapshot.get_allocation(asset).value
                asset_values_dict['timestamp'] = timestamp
                asset_values_dict['total_value'] = current_value_of_portfolio
                asset_values_dict['total_value_usdt'] = current_snapshot.total_value('USDT')
                value_df_dicts.append(asset_values_dict)
                previous_snapshot = current_snapshot
            except NoPriceDataException as e:
                logging.error(e)
                continue
        self._dataframes = {asset: pd.DataFrame(self._dataframes[asset]).set_index(['timestamp']) for asset in self._dataframes.keys()}
        self._value_dataframe = pd.DataFrame(value_df_dicts).set_index(['timestamp'])
        self._value_dataframe = self._fill_relative_returns(self._value_dataframe,
                                                            total_value_column_name='total_value',
                                                            relative_returns_column_name='return_relative_to_past_tick')
        self._value_dataframe = self._fill_relative_returns(self._value_dataframe,
                                                            total_value_column_name='total_value_usdt',
                                                            relative_returns_column_name='return_relative_to_past_tick_usdt')

        # self._value_dataframe.index = pd.to_datetime(self._value_dataframe.index, unit='s')

    def _get_next_snapshot(self, current_snapshot, timestamp, previous_snapshot):
        if timestamp in self._portfolio_snapshots:
            return self._portfolio_snapshots[timestamp]    # we have a rebalancing checkpoint here
        else:
            return current_snapshot.update_to_timestamp(timestamp)   # just recalculate value and return


    def _fill_relative_returns(self, df, total_value_column_name='total_value', relative_returns_column_name='return_relative_to_past_tick'):
        df['return_relative_to_past_tick'] = df[total_value_column_name].diff() / df[total_value_column_name].shift(1)
        return df

    def process_allocations(self, timestamp, allocations_data):
        self._portfolio_snapshots[timestamp] = PortfolioSnapshot(timestamp, allocations_data)

    def value_report(self):
        for timestamp, snapshot in self._portfolio_snapshots.items():
            snapshot.report()

    def get_dataframe_for_asset(self, asset):
        return self._dataframes.get(asset, None)

    def get_rebalancing_vs_benchmark_dataframe(self):
        value_df = self.value_dataframe
        benchmark_value_df = self.get_benchmark_trading_df_for_all_assets()

        df = value_df.join(benchmark_value_df, lsuffix='_rebalancing', rsuffix='_benchmark')
        columns_list = [f'total_value_{asset}' for asset in self.held_assets]
        columns_list.append('total_value_rebalancing')
        columns_list.append('total_value_benchmark')
        df.index = pd.to_datetime(df.index, unit='s')
        return df

    @property
    def value_dataframe(self):
        return self._value_dataframe

    @property
    def held_assets(self):
        return self._portions_dict.keys()

    def get_benchmark_for_asset(self, asset):
        return self._benchmarks.get(asset, None)

    def get_benchmark_trading_dataframe_for_asset(self, asset):
        if asset not in self._benchmarks:
            return None
        return self._benchmarks[asset].trading_df

    def _fill_benchmark_dataframe(self):
        df = None
        for asset in self.held_assets:
            if df is None:
                df = self._benchmarks[asset].trading_df.copy()
                df = df.add_suffix(f'_{asset}')
                right_usdt = self._usdt_benchmarks[asset].trading_df.copy().add_suffix(f'_usdt_{asset}')
                df = df.join(right_usdt)
            else:
                right = self._benchmarks.get(asset, None).trading_df.add_suffix(f'_{asset}')
                df = df.join(right)
                right_usdt = self._usdt_benchmarks[asset].trading_df.copy().add_suffix(f'_usdt_{asset}')
                df = df.join(right_usdt)
        sum_columns = [f'total_value_{asset}' for asset in self.held_assets]
        df['total_value'] = df[sum_columns].sum(axis=1)
        df = self._fill_relative_returns(df, total_value_column_name='total_value', 
                                         relative_returns_column_name='return_relative_to_past_tick')

        sum_columns_usdt = [f'total_value_usdt_{asset}' for asset in self.held_assets]
        df['total_value_usdt'] = df[sum_columns_usdt].sum(axis=1)
        df = self._fill_relative_returns(df, total_value_column_name='total_value_usdt', 
                                         relative_returns_column_name='return_relative_to_past_tick_usdt')

        self._benchmark_dataframe = df

    def get_benchmark_trading_df_for_all_assets(self):
        return self._benchmark_dataframe

    @property
    def profit(self):
        end_value = self.value_dataframe.iloc[-1].total_value
        return end_value - self._start_value_of_portfolio

    @property
    def profit_usdt(self):
        end_value = self.value_dataframe.iloc[-1].total_value_usdt
        return end_value - self._start_value_of_portfolio_usdt

    @property
    def profit_percent(self):
        return self.profit / float(self._start_value_of_portfolio)

    @property
    def profit_percent_usdt(self):
        return self.profit_usdt / float(self._start_value_of_portfolio_usdt)

    @property
    def benchmark_profit(self):
        end_value = self._benchmark_dataframe.iloc[-1].total_value
        return end_value - self._start_value_of_portfolio

    @property
    def benchmark_profit_usdt(self):
        end_value = self._benchmark_dataframe.iloc[-1].total_value_usdt
        return end_value - self._start_value_of_portfolio_usdt

    @property
    def benchmark_profit_percent(self):
        return self.benchmark_profit / float(self._start_value_of_portfolio)

    @property
    def benchmark_profit_percent_usdt(self):
        return self.benchmark_profit_usdt / float(self._start_value_of_portfolio_usdt)

    @property
    def gain_over_benchmark(self):
        return self.profit - self.benchmark_profit

    @property
    def gain_over_benchmark_usdt(self):
        return self.profit_usdt - self.benchmark_profit_usdt

    @property
    def percent_gain_over_benchmark(self):
        return self.gain_over_benchmark / self._start_value_of_portfolio

    @property
    def percent_gain_over_benchmark_usdt(self):
        return self.gain_over_benchmark_usdt / self._start_value_of_portfolio_usdt

    @property
    def summary_dict(self):
        return {
            'allocations': ', '.join([f'{asset} ({self.get_portion(asset)*100:.0f}%)' for asset in self.held_assets]),
            'profit_percent': self.profit_percent,
            'profit_percent_usdt': self.profit_percent_usdt,
            'benchmark_profit_percent': self.benchmark_profit_percent,
            'benchmark_profit_percent_usdt': self.benchmark_profit_percent_usdt,
            'percent_gain_over_benchmark': self.percent_gain_over_benchmark,
            'percent_gain_over_benchmark_usdt': self.percent_gain_over_benchmark_usdt,
            'gain_over_benchmark': self.gain_over_benchmark,
            'gain_over_benchmark_usdt': self.gain_over_benchmark_usdt
        }

    def get_portion(self, asset):
        return self._portions_dict.get(asset, None)

    def draw_returns_tear_sheet(self, save_file=True, out_filename='pyfolio_returns_tear_sheet.png'):
        import pyfolio as pf
        import matplotlib
        if save_file:
           matplotlib.use('Agg')

        df = self.get_rebalancing_vs_benchmark_dataframe()
        df = df.rename(columns={"return_relative_to_past_tick_benchmark": "Buy & hold"})
        f = pf.create_returns_tear_sheet(returns=df['return_relative_to_past_tick_rebalancing'],
                                         return_fig=True,
                                         bootstrap=None,
                                         benchmark_rets=df['Buy & hold'])

        if save_file:
            f.savefig(out_filename)
        return f

    def plot_returns(self, title=None):
        if title is None:
            title = self.summary_dict['allocations']
        self.get_rebalancing_vs_benchmark_dataframe()[
            ['total_value_usdt_rebalancing', 'total_value_usdt_benchmark']].plot(title=title)

    def save_returns_plot(self, out_file_path, title=None):
        if title is None:
            title = self.summary_dict['allocations']
        chart = self.get_rebalancing_vs_benchmark_dataframe()[
            ['total_value_usdt_rebalancing', 'total_value_usdt_benchmark']].plot(title=title)
        chart.set_xlabel('')
        chart.set_ylabel('')
        chart.legend(['total value usdt rebalancing', 'buy & hold'])
        fig = chart.get_figure()
        fig.savefig(out_file_path)
        return fig



class RebalancingStrategyBacktester(PortfolioBacktester):
    '''
    Enables backtesting an arbitrary rebalancing strategy.
    '''

    def __init__(self, portfolio_snapshots, *args, **kwargs):
        '''
        Constructs the rebalancing strategy backtester.
        :param portfolio_snapshots: a dictionary of pairs <timestamp>-<PortfolioSnapshot> generated by the strategy
        :param args: arguments for the super constructor (see PortfolioBacktester)
        :param kwargs: arguments for the super constructor (see PortfolioBacktester)
        '''
        self._cached_portfolio_snapshots = portfolio_snapshots
        super().__init__(*args, **kwargs)

    def _build_portfolio_snapshots(self):
        self._portfolio_snapshots = self._cached_portfolio_snapshots



class FixedRatiosPortfolioBacktester(PortfolioBacktester):
    '''
    A backtester that assumes fixed preset asset ratios (e.g. 50% BTC, 50% ETH) and simulates the performance
    of the portfolio assuming these ratios are kept.
    '''

    def __init__(self, rebalancing_period_seconds, portions_dict,
                 start_value_of_portfolio, *args, **kwargs):
        '''
        Builds and runs the fixed ratios backtester.
        :param rebalancing_period_seconds: how often to rebalance the portfolio
        :param portions_dict: a dictionary of key-value pairs where key is
                              the name of the asset and value is the portion (on a scale 0-1)
        :param start_value_of_portfolio: start value of the p
        :param args: arguments for the super constructor (see PortfolioBacktester)
        :param kwargs: arguments for the super constructor (see PortfolioBacktester)
        '''
        self._rebalancing_period_seconds = rebalancing_period_seconds
        self._portions_dict = portions_dict
        self._start_value_of_portfolio = start_value_of_portfolio
        super().__init__(*args, **kwargs)


    def _build_portfolio_snapshots(self):
        self._portfolio_snapshots = OrderedDict()
        current_snapshot = None
        for timestamp in range(self._start_time, self._end_time + 1, self._rebalancing_period_seconds):
            try:
                previous_snapshot = current_snapshot
                current_snapshot = self._get_next_snapshot(current_snapshot, timestamp, previous_snapshot)
                self._portfolio_snapshots[timestamp] = current_snapshot
            except NoPriceDataException:
                logging.error(f'Unable to load price data at {timestamp}, skipping snapshot...')


    def _get_next_snapshot(self, current_snapshot, timestamp, previous_snapshot):
        if current_snapshot is None:
            current_snapshot = self._build_portfolio_with_trading_fee(self._start_time, self._start_value_of_portfolio,
                                                                      previous_portfolio=None)
        else:
            current_snapshot = self._build_portfolio_with_trading_fee(
                timestamp, current_snapshot.update_to_timestamp(timestamp).total_value(self._counter_currency),
                previous_portfolio=previous_snapshot)
        return current_snapshot

    def _build_portfolio(self, timestamp, total_value):
        allocations = []
        # calculate the held amount for each asset
        for asset in self._portions_dict:
            portion = self._portions_dict[asset]
            unit_price = PRICE_PROVIDER.get_price(asset, timestamp)
            value = (portion * total_value) * (1 - self._trading_cost_percent/100)
            amount = value / unit_price
            allocation = Allocation(amount=amount, asset=asset, portion=portion, timestamp=timestamp,
                                    counter_currency=self._counter_currency, unit_price=unit_price, value=value)
            allocations.append(allocation)
        return PortfolioSnapshot(timestamp=timestamp, allocations_data=allocations,
                                 load_from_json=False, counter_currency=self._counter_currency)

    def _build_portfolio_with_trading_fee(self, timestamp, total_value, previous_portfolio):
        if previous_portfolio is None:
            return self._build_portfolio(timestamp, total_value)
        allocations = []
        trading_fee = self._trading_cost_percent / 100
        # calculate the held amount for each asset
        for asset in self._portions_dict:
            previous = previous_portfolio.get_allocation(asset)
            new_unit_price = PRICE_PROVIDER.get_price(asset, timestamp)
            portion = self._portions_dict[asset]
            delta_value = abs(total_value*portion - previous.amount*new_unit_price)
            fee = delta_value * trading_fee
            obtained_amount = (delta_value - fee) / new_unit_price
            new_amount = previous.amount + (obtained_amount if total_value*portion > previous.amount*new_unit_price else -obtained_amount)
            new_value = new_amount * new_unit_price
            portion = new_value / total_value
            # amount = value / unit_price
            allocation = Allocation(amount=new_amount, asset=asset, portion=portion, timestamp=timestamp,
                                    counter_currency=self._counter_currency, unit_price=new_unit_price, value=new_value)
            allocations.append(allocation)
        total_value = sum([allocation.value for allocation in allocations])
        for allocation in allocations:
            allocation.portion = allocation.value / total_value

        p = PortfolioSnapshot(timestamp=timestamp, allocations_data=allocations, load_from_json=False)
        return p



from apps.portfolio.services.doge_votes import get_allocations_from_doge

class DogeRebalancingBacktester(PortfolioBacktester):
    '''
    Enables backtesting committee-based rebalancing
    '''

    def __init__(self, rebalancing_period_seconds, *args, **kwargs):
        self._rebalancing_period_seconds = rebalancing_period_seconds
        super().__init__(*args, **kwargs)

    def _build_portfolio_snapshots(self):
        from apps.backtesting.utils import datetime_from_timestamp
        import datetime

        self._portfolio_snapshots = OrderedDict()
        for timestamp in range(self._start_time, self._end_time + 1, self._rebalancing_period_seconds):
            try:
                doge_allocations, _ = get_allocations_from_doge(at_datetime=datetime.datetime.utcfromtimestamp(timestamp))
                allocation_objects = self._doge_allocations_to_objects(doge_allocations, timestamp)
                snapshot = PortfolioSnapshot(timestamp=timestamp, allocations_data=allocation_objects, load_from_json=False)
                self._portfolio_snapshots[timestamp] = snapshot
            except NoPriceDataException:
                logging.error(f'Unable to load price data at {timestamp}, skipping snapshot...')

    def _doge_allocations_to_objects(self, doge_allocations, timestamp):
        allocation_objects = []
        for doge_allocation in doge_allocations:
            allocation_object = Allocation(
                amount=doge_allocation['amount'],
                asset=doge_allocation['coin'],
                portion=doge_allocation['portion'],
                timestamp=timestamp,
                counter_currency=self._counter_currency
            )
            allocation_objects.append(allocation_object)
        return allocation_objects



class DummyDataProvider:
    sample_allocations = """
    [{
        "amount": 0.00695246,
        "asset": "BTC",
        "portion": 0.5
    },{
        "amount": 0.05294586,
        "asset": "ETH",
        "portion": 0.5
    }]

    """

    def run(self):
        from apps.backtesting.utils import datetime_to_timestamp, datetime_from_timestamp
        # backtester = PortfolioBacktester()
        timestamp = datetime_to_timestamp('2019/02/01 00:00:00 UTC')
        # for i in range(10):
        #     backtester.process_allocations(timestamp+i*60*60*24, self.sample_allocations)
        # backtester.value_report()
        snapshot = PortfolioSnapshot(timestamp, DummyDataProvider.sample_allocations)
        portfolio_snapshots = [PortfolioSnapshot(timestamp, DummyDataProvider.sample_allocations)] * 5

        end_time = 1548250130  # time.time()
        start_time = end_time - 60 * 60 * 24 * 7

        backtester = DogeRebalancingBacktester(start_time=datetime_from_timestamp(start_time),
                                               end_time=datetime_from_timestamp(end_time),
                                               step_seconds=60 * 60,
                                               rebalancing_period_seconds=60 * 60,
                                               counter_currency='USDT')

        exit(0)


        backtester = FixedRatiosPortfolioBacktester(start_time=int(datetime_to_timestamp('2018/10/01 00:00:00 UTC')),
                            end_time=int(datetime_to_timestamp('2018/10/30 00:00:00 UTC')),
                            step_seconds=60*60,
                            rebalancing_period_seconds=60*60,
                            portions_dict={
                                'BTC': 0.5,
                                'ETH': 0.5,
                            },
                            start_value_of_portfolio=1000,
                            counter_currency='USDT',
                            trading_cost_percent=0.1) #, portfolio_snapshots=portfolio_snapshots)
        backtester.draw_returns_tear_sheet()
        backtester.get_benchmark_trading_dataframe_for_asset('ETH')
        backtester.get_benchmark_trading_df_for_all_assets()
        backtester.get_rebalancing_vs_benchmark_dataframe()

if __name__ == '__main__':
    d = DummyDataProvider()
    d.run()
